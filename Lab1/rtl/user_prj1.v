// This code snippet was auto generated by xls2vlog.py from source file: ./user_project_wrapper.xlsx
// User: josh
// Date: Sep-22-23


module USER_PRJ1 #( parameter pUSER_PROJECT_SIDEBAND_WIDTH   = 5,
          parameter pADDR_WIDTH   = 12,
                   parameter pDATA_WIDTH   = 32
                 )
(
  output wire                        awready,
  output wire                        arready,
  output wire                        wready,
  output wire                        rvalid,
  output wire  [(pDATA_WIDTH-1) : 0] rdata,
  input  wire                        awvalid,
  input  wire                [11: 0] awaddr,
  input  wire                        arvalid,
  input  wire                [11: 0] araddr,
  input  wire                        wvalid,
  input  wire                 [3: 0] wstrb,
  input  wire  [(pDATA_WIDTH-1) : 0] wdata,
  input  wire                        rready,
  input  wire                        ss_tvalid,
  input  wire  [(pDATA_WIDTH-1) : 0] ss_tdata,
  input  wire                 [1: 0] ss_tuser,
    `ifdef USER_PROJECT_SIDEBAND_SUPPORT
  input  wire                 [pUSER_PROJECT_SIDEBAND_WIDTH-1: 0] ss_tupsb,
  `endif
  input  wire                 [3: 0] ss_tstrb,
  input  wire                 [3: 0] ss_tkeep,
  input  wire                        ss_tlast,
  input  wire                        sm_tready,
  output wire                        ss_tready,
  output wire                        sm_tvalid,
  output wire  [(pDATA_WIDTH-1) : 0] sm_tdata,
  output wire                 [2: 0] sm_tid,
  `ifdef USER_PROJECT_SIDEBAND_SUPPORT
  output  wire                 [pUSER_PROJECT_SIDEBAND_WIDTH-1: 0] sm_tupsb,
  `endif
  output wire                 [3: 0] sm_tstrb,
  output wire                 [3: 0] sm_tkeep,
  output wire                        sm_tlast,
  output wire                        low__pri_irq,
  output wire                        High_pri_req,
  output wire                [23: 0] la_data_o,
  input  wire                        axi_clk,
  input  wire                        axis_clk,
  input  wire                        axi_reset_n,
  input  wire                        axis_rst_n,
  input  wire                        user_clock2,
  input  wire                        uck2_rst_n
);


// assign awready       = 1'b0;
// assign arready       = 1'b0;
// assign wready        = 1'b0;
// assign rvalid        = 1'b0;
// assign rdata         = {pDATA_WIDTH{1'b0}};
// assign ss_tready     = 1'b0;
// assign sm_tvalid     = 1'b0;
// assign sm_tdata      = {pDATA_WIDTH{1'b0}};
assign sm_tid        = 3'b0;
`ifdef USER_PROJECT_SIDEBAND_SUPPORT
  assign sm_tupsb      = 5'b0;
`endif
assign sm_tstrb      = 4'b0;
assign sm_tkeep      = 1'b0;
assign sm_tlast      = 1'b0;
assign low__pri_irq  = 1'b0;
assign High_pri_req  = 1'b0;
assign la_data_o     = 24'b0;

// tap_ram
wire [3:0]  tap_WE;
wire        tap_EN;
wire [11:0] tap_A;
wire [31:0] tap_Di, tap_Do;

bram11 tap_ram(
    .clk(axi_clk),
    .we(|tap_WE),
    .re(tap_EN),
    .waddr(tap_A),
    .raddr(tap_A),
    .wdi(tap_Di),
    .rdo(tap_Do)
);

// data_ram
wire [3:0]  data_WE;
wire        data_EN;
wire [11:0] data_A;
wire [31:0] data_Di, data_Do;
bram11 data_ram(
    .clk(axi_clk),
    .we(|data_WE),
    .re(data_EN),
    .waddr(data_A),
    .raddr(data_A),
    .wdi(data_Di),
    .rdo(data_Do)
);

// fir_module
fir inst_fir(
    .awready(awready),
    .wready(wready),
    .awvalid(awvalid),
    .awaddr(awaddr),
    .wvalid(wvalid),
    .wdata(wdata),
    .arready(arready),
    .rready(rready),
    .arvalid(arvalid),
    .araddr(araddr),
    .rvalid(rvalid),
    .rdata(rdata),    
    .ss_tvalid(ss_tvalid), 
    .ss_tdata(ss_tdata), 
    .ss_tlast(), 
    .ss_tready(ss_tready), 
    .sm_tready(sm_tready), 
    .sm_tvalid(sm_tvalid), 
    .sm_tdata(sm_tdata), 
    .sm_tlast(), 
    
    .tap_WE(tap_WE),
    .tap_EN(tap_EN),
    .tap_Di(tap_Di),
    .tap_A(tap_A),
    .tap_Do(tap_Do),
    
    .data_WE(data_WE),
    .data_EN(data_EN),
    .data_Di(data_Di),
    .data_A(data_A),
    .data_Do(data_Do),

    .axis_clk(axi_clk),
    .axis_rst_n(axi_reset_n)
);


endmodule // USER_PRJ1


module fir 
#(  parameter pADDR_WIDTH = 12,
    parameter pDATA_WIDTH = 32,
    parameter Tape_Num    = 10 //actually Tape_Num is Tape_Num+1
)
(
    output  wire                     awready, // coefficients address ready to accept from tb, not used
    output  wire                      wready,  // coefficients ready to accept from tb
    input   wire                     awvalid, // coefficients address valid
    input   wire [(pADDR_WIDTH-1):0] awaddr,  // coefficients address
    input   wire                     wvalid, // coefficients valid
    input   wire [(pDATA_WIDTH-1):0] wdata,  //coefficients comes from here

    //can be either check coefficients or ap_done/ap_idle
    output  wire                     arready, // data address ready to accept from tb, not used
    input   wire                     rready, // tb is ready to accept data
    input   wire                     arvalid, // read address from tb is valid
    input   wire [(pADDR_WIDTH-1):0] araddr, // read address from tb
    output  reg                      rvalid, // data to tb valid
    output  reg  [(pDATA_WIDTH-1):0] rdata,  // data to tb

    input   wire                     ss_tvalid, //data stream in valid
    input   wire [(pDATA_WIDTH-1):0] ss_tdata, //data stream in
    input   wire                     ss_tlast, //data stream in last
    output  reg                      ss_tready, //ready to accept data stream in

    input   wire                     sm_tready, //tb ready to accept data stream out
    output  reg                      sm_tvalid, //data stream out valid
    output  reg  [(pDATA_WIDTH-1):0] sm_tdata, //data stream out
    output  reg                      sm_tlast, //data stream out last
    
    // bram for tap RAM
    output  reg  [3:0]               tap_WE,
    output  wire                     tap_EN,
    output  reg  [(pDATA_WIDTH-1):0] tap_Di,
    output  wire   [(pADDR_WIDTH-1):0] tap_A,
    input   wire [(pDATA_WIDTH-1):0] tap_Do,

    // bram for data RAM
    output  reg  [3:0]               data_WE,
    output  wire                     data_EN,
    output  reg  [(pDATA_WIDTH-1):0] data_Di,
    output  wire [(pADDR_WIDTH-1):0] data_A,
    input   wire [(pDATA_WIDTH-1):0] data_Do,

    input   wire                     axis_clk,
    input   wire                     axis_rst_n
);
// states
localparam S_RESET_RAM = 0;
localparam S_COMPUTE = 1;
localparam S_READY = 2;
localparam S_DONE = 3;
localparam S_FIN = 4;
localparam S_WAIT_START = 5;

// regs and wires declaration
reg ap_done_w, ap_done_r;
reg ap_idle_w, ap_idle_r;
reg ap_start_w, ap_start_r;
reg rvalid_w;
reg [(pDATA_WIDTH-1):0] rdata_w;
reg read_axil_wait_w, read_axil_wait_r;
reg tap_A_read, tap_A_write;
reg [(pDATA_WIDTH-1):0] data_len_w,data_len_r;
wire [31:0] addr_map_0_data;
reg [3:0] data_A_byte;

reg [3:0] state_w, state_r;


reg [3:0] data_addr_cnt_w, data_addr_cnt_r;
reg [3:0] data_addr_base_w, data_addr_base_r;
reg [(pDATA_WIDTH-1):0] res_w,res_r;

reg last_one_w, last_one_r;

wire [31:0] mac_result;

// assignment
assign addr_map_0_data = {{29{1'b0}},ap_idle_r,ap_done_r,ap_start_r};
assign tap_EN = 1'b1;
assign data_EN = 1'b1;
assign tap_A =  tap_A_write ? awaddr-64 : 
                tap_A_read ? araddr-64 : data_addr_cnt_r;
assign wready = awvalid && wvalid;
assign awready = awvalid && wvalid;
assign data_A = data_A_byte;

assign arready = 1;

assign mac_result = $signed(res_r) + $signed($signed(data_Do) * $signed(tap_Do));
//module instances

// reg [64:0] cycle_cnt;
// always @(posedge axis_clk or negedge axis_rst_n) begin
//     if(!axis_rst_n) begin
//         cycle_cnt <= 0;
//     end 
//     else begin
//         cycle_cnt <= cycle_cnt + 1;
//     end
// end



// combinational block

//state machine
always @(*) begin
    state_w = state_r;
    case (state_r)
        S_RESET_RAM:begin
            if(data_addr_cnt_r == Tape_Num)begin
                //$display("RESET_RAM DONE");
                state_w = S_WAIT_START;
            end
        end
        S_WAIT_START:begin
            if(ap_start_r)begin
                //$display("AP START RECEIVED");
                state_w = S_READY;
            end
        end
        S_READY:begin
            if(ss_tvalid)begin
                state_w = S_COMPUTE;
            end
        end
        S_COMPUTE:begin
            if(data_addr_cnt_r == Tape_Num)begin
                state_w = S_DONE;
            end
        end
        S_DONE:begin
            if(sm_tready)begin
                //$display("sm_tdata = %d", $signed(res_r));
                if(last_one_r) 
                    state_w = S_FIN;
                else
                    state_w = S_READY;
            end
        end
        
    endcase
end

//debug

// always @(posedge axis_clk)begin
//     case (state_r)
//         S_COMPUTE:begin
//             $display("---------------------------------------");
//             $display("tap_Do = %d", $signed(tap_Do));
//             $display("data_Do = %d", $signed(data_Do));
//             $display("data_addr_cnt_r = %d", data_addr_cnt_r);
//             $display("mac_result = %d", $signed(mac_result));
//             $display("---------------------------------------");
//         end
//     endcase
// end

//computation part
always @(*) begin
    data_addr_cnt_w = data_addr_cnt_r;
    data_WE = 4'b0000;
    data_Di = 0;
    data_A_byte = 0;
    ap_done_w = ap_done_r;
    ap_idle_w = ap_idle_r;
    data_addr_base_w = data_addr_base_r;
    last_one_w = last_one_r;

    ss_tready = 0;
    sm_tvalid = 0;
    sm_tdata = 0;
    res_w = res_r;
    case (state_r)
        S_RESET_RAM:begin
            data_WE = 4'b1111;
            data_Di = 0;
            data_A_byte = data_addr_cnt_r;
            if (data_addr_cnt_r == Tape_Num)begin
                data_addr_cnt_w = data_addr_cnt_r;
                ap_idle_w = 0;
            end
            else begin
                data_addr_cnt_w = data_addr_cnt_r + 1;
            end
        end

        S_WAIT_START:begin
            data_addr_cnt_w = 0;
        end

        S_READY:begin
            ss_tready = 1;
            res_w = 0;

            if(ss_tvalid)begin
                //$display("ss_tdata = %d", $signed(ss_tdata));
                data_Di = ss_tdata;
                data_WE = 4'b1111;
                data_A_byte = data_addr_base_r;
            end
        end
        S_COMPUTE:begin
            res_w = mac_result;
            data_A_byte = (data_addr_base_r + data_addr_cnt_r > Tape_Num) ? 
                        data_addr_base_r + data_addr_cnt_r - Tape_Num - 1 : 
                        data_addr_base_r + data_addr_cnt_r;
            if(data_addr_cnt_r == Tape_Num)begin
                data_addr_cnt_w = 0;
                if(data_addr_base_r == 0)begin
                    data_addr_base_w = Tape_Num;
                end
                else begin
                    data_addr_base_w = data_addr_base_r - 1;
                end
                if(ss_tlast)begin
                    ap_done_w = 1;
                    ap_idle_w = 1;
                end
            end
            else begin
                data_addr_cnt_w = data_addr_cnt_r + 1;
            end
        end
        S_DONE:begin
            sm_tvalid = 1;
            sm_tdata = res_r;
            if(sm_tready)begin
                res_w = 0;
                last_one_w = ss_tlast;
            end
        end
        S_FIN:begin
        end

    endcase
end

//write axil
always @(*) begin
    tap_A_write = 0;
    tap_Di = 0;
    tap_WE = 0;
    ap_start_w = 0;
    data_len_w = data_len_r;
    if(awvalid && wvalid)begin
        // $display("awaddr = %d",awaddr);
        // $display("wdata = %d, at cycle = %d",$signed(wdata),cycle_cnt);
        if(awaddr >= 64)begin
            tap_A_write = 1;
            tap_Di = wdata;
            tap_WE = 4'b1111;
        end
        else begin
            if (awaddr == 0)begin
                ap_start_w = 1;
            end
            else begin // write data length
                data_len_w = wdata;
            end
        end
    end
end

//read axil
always @(*) begin
    rvalid_w = 0;
    rdata_w = 0;
    read_axil_wait_w = 0;
    tap_A_read = 0;
    if(arvalid)begin
        //$display("araddr = %d",araddr);
        if(araddr == 0)begin
            rdata_w = addr_map_0_data;
            rvalid_w = 1;
            //$display("rdata = %b, at cycle = %d",addr_map_0_data[5:0],cycle_cnt);
        end
        else begin
            if(read_axil_wait_r == 0) begin
                read_axil_wait_w = 1;
                tap_A_read = 1;
            end
            else begin
                rdata_w = tap_Do;
                rvalid_w = 1;
            end
            
        end
    end
end


// sequencial block
always @(posedge axis_clk or negedge axis_rst_n) begin
    if(!axis_rst_n) begin
        // reset
        //$display("-----------reset-----------");
        ap_done_r <= 1'b0;
        ap_idle_r <= 1'b1; //not sure
        ap_start_r <= 1'b0;
        rdata <= 0;
        rvalid <= 0;
        read_axil_wait_r <= 0;
        data_len_r <= 0;
        data_addr_cnt_r <= 0;
        state_r <= S_RESET_RAM;
        data_addr_base_r <= Tape_Num;
        res_r <= 0;
        last_one_r <= 0;
    end 
    else begin
        // normal
        ap_done_r <= ap_done_w;
        ap_idle_r <= ap_idle_w;
        ap_start_r <= ap_start_w;
        rdata <= rdata_w;
        rvalid <= rvalid_w;
        read_axil_wait_r <= read_axil_wait_w;
        data_len_r <= data_len_w;
        data_addr_cnt_r <= data_addr_cnt_w;
        state_r <= state_w;
        data_addr_base_r <= data_addr_base_w;
        res_r <= res_w;
        last_one_r <= last_one_w;
    end
end
endmodule

module bram11 (clk, we, re, waddr, raddr, wdi, rdo);
    `define RAMinitFile "./init.dat"
    parameter ADDR_WIDTH = 12;
    parameter SIZE = 11;
    parameter BIT_WIDTH = 32;
    input                          clk;
    input                          we, re;
    input [ADDR_WIDTH-1:0]         waddr, raddr;
    input [BIT_WIDTH-1:0]          wdi;
    output reg [BIT_WIDTH-1:0]     rdo;
    reg [BIT_WIDTH-1:0] RAM [SIZE-1:0];
    /////initial $readmemh(`RAMinitFile, RAM);

    wire [BIT_WIDTH-1:0] ram0 = RAM[0];
    wire [BIT_WIDTH-1:0] ram1 = RAM[1];
    wire [BIT_WIDTH-1:0] ram2 = RAM[2];
    wire [BIT_WIDTH-1:0] ram3 = RAM[3];
    wire [BIT_WIDTH-1:0] ram4 = RAM[4];
    wire [BIT_WIDTH-1:0] ram5 = RAM[5];
    wire [BIT_WIDTH-1:0] ram6 = RAM[6];
    wire [BIT_WIDTH-1:0] ram7 = RAM[7];
    wire [BIT_WIDTH-1:0] ram8 = RAM[8];
    wire [BIT_WIDTH-1:0] ram9 = RAM[9];
    wire [BIT_WIDTH-1:0] ram10 = RAM[10];
    
    always @(posedge clk)begin
        if(re) rdo <= RAM[raddr];
    end
    
    always @(posedge clk)begin
        if(we) RAM[waddr] <= wdi;
    end
    
endmodule
